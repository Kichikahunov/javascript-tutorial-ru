# Fetch API

На данный момент мы уже многое знаем про `fetch`.

Теперь давайте рассмотрим оставшуюся часть API, чтобы охватить все его возможности.

Нижеследующий список - это все возможные опции для `fetch` с соответствующими значениями по умолчанию (в комментариях указаны альтернативные значения):

```js
let promise = fetch(url, {
  method: "GET", // POST, PUT, DELETE, etc.
  headers: {
    // значение этого заголовка обычно ставится автоматически, в зависимости от тела запроса
    "Content-Type": "text/plain;charset=UTF-8"
  },
  body: undefined // string, FormData, Blob, BufferSource или URLSearchParams
  referrer: "about:client", // или "" для того, чтобы не послать заголовок Referer, или URL с текущего источника
  referrerPolicy: "no-referrer-when-downgrade", // no-referrer, origin, same-origin...
  mode: "cors", // same-origin, no-cors
  credentials: "same-origin", // omit, include
  cache: "default", // no-store, reload, no-cache, force-cache или only-if-cached
  redirect: "follow", // manual, error
  integrity: "", // контрольная сумма, например "sha256-abcdef1234567890"
  keepalive: false, // true
  signal: undefined, // AbortController, чтобы прервать запрос
  window: window // null
});
```

Довольно-таки внушительный список, не так ли?

В главе <info:fetch> мы полностью охватили параметры `method`, `headers` и `body`.

Опция `signal` разъяснена в главе в <info:fetch-abort>.

Теперь давайте пройдёмся по оставшимся опциям.

## referrer, referrerPolicy

Данные опции определяют, как `fetch` устанавливает HTTP-заголовок `Referer`.

В заголовке указывается URL-адрес страницы, с которой пришёл запрос. В большинстве случаев он играет совсем небольшую роль, однако в некоторых случаях, с целью большей безопасности, имеет смысл убрать или укоротить его.

**Опция `referrer` позволяет установить любой `Referer` в пределах текущего источника или же отключить его.**

Чтобы не отправлять Referer, нужно указать значением пустую строку:
```js
fetch('/page', {
*!*
  referrer: "" // отсутствует Referer заголовок
*/!*
});
```

Для того, чтобы установить другой URL-адрес для текущего источника:

```js
fetch('/page', {
  // предположим, что мы находимся на странице https://javascript.info
  // мы можем установить любое значение Referer при условии, что оно принадлежит текущему источнику
*!*
  referrer: "https://javascript.info/anotherpage"
*/!*
});
```

**Опция `referrerPolicy` устанавливает общие правила для `Referer`.**

Возможные значения описаны в [спецификации Referrer Policy](https://w3c.github.io/webappsec-referrer-policy/):

- **`"no-referrer-when-downgrade"`** -- значение по умолчанию: `Referer` отправляется всегда, если только мы не отправим запрос из HTTPS в HTTP (из более безопасного протокола в менее безопасный).
- **`"no-referrer"`** -- никогда не отправлять `Referer`.
- **`"origin"`** -- отправлять в `Referer` только текущий источник, а не полный URL-адрес страницы, например, послать `http://site.com` вместо `http://site.com/path`.
- **`"origin-when-cross-origin"`** -- отправлять полный Referer для запросов в пределах текущего источника, но для кроссдоменных запросов отправлять только само значение источника
- **`"same-origin"`** -- отправлять полный Referer для запросов в пределах текущего источника, а для кроссдоменных запросов не отправлять referer вообще.
- **`"strict-origin"`** -- отправлять только значение источника, не отправлять Referer для HTTPS→HTTP запросов.
- **`"strict-origin-when-cross-origin"`** -- для запросов в пределах текущего источника отправлять полный Referer, для кроссдоменных запросов отправлять только значение источника, в случае HTTPS→HTTP запросов не отправлять ничего.
- **`"unsafe-url"`** -- всегда отправлять полный URL-адрес в `Referer`.

Допустим, у нас есть админка со структурой URL, которая не должна стать известной снаружи сайта.

Если мы отправляем кроссдоменный запрос `fetch`, то по умолчанию он отправит заголовок `Referer` с полным URL-адресом нашей админки (исключение - это когда мы делаем запрос от HTTPS в HTTP, в таком случае `Referer` не будет отправляться).

Например, `Referer: https://javascript.info/admin/secret/paths`.

Если же мы хотим полностью скрыть его:

```js
fetch('https://another.com/page', {
  referrerPolicy: "no-referrer" // не посылать Referer - даёт такой же результат, как и referrer: ""
});
```

Или же, если мы хотим, чтобы удалённая сторона знала домен, откуда поступает запрос, но не полный URL, мы можем отправить только источник:

```js
fetch('https://another.com/page', {
  referrerPolicy: "strict-origin" // Referer: https://javascript.info
});
```

## mode

Опция `mode` - это надёжная защита от кроссдоменных запросов:

- **`"cors"`** -- стоит по умолчанию, позволяет делать кроссдоменные запросы так, как описано в <info:fetch-crossorigin>,
- **`"same-origin"`** -- кроссдоменные запросы запрещены,
- **`"no-cors"`** -- разрешены только простые кроссдоменные запросы.

Это может пригодиться, если URL-адрес для fetch приходит от третьего лица, и нам нужно что-то, чтобы контролировать ограничение кроссдоменных возможностей - эдакий "выключатель".

## credentials

Опция `credentials` может указывать, должен ли `fetch` отправлять cookies и аутентификационные заголовки HTTP вместе с запросом.

- **`"same-origin"`** -- стоит по умолчанию, не отправлять для кроссдоменных запросов,
- **`"include"`** -- отправлять всегда, но при этом необходимы `Access-Control-Allow-Credentials` заголовки в ответе от кроссдоменного сервера,
- **`"omit"`** -- не отправлять ни при каких обстоятельствах, даже для запросов, сделанных в пределах текущего источника.

## Кеш

По умолчанию `fetch` делает запросы, используя стандартный HTTP-кешинг. То есть, он учитывает заголовки `Expires`, `Cache-Control`, отправляет `If-Modified-Since` и так далее. Так же, как и обычные HTTP-запросы.

Опция `cache` позволяет игнорировать HTTP-кеш или же настроить его использование:

- **`"default"`** -- `fetch` будет использовать стандартные правила и заголовки HTTP кеширования;
- **`"no-store"`** -- полностью игнорировать HTTP-кеш, этот режим становится режимом по умолчанию, если присутствуют такие заголовки как `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, или `If-Range`;
- **`"reload"`** -- не брать результат из HTTP-кеша (даже при его присутствии), но сохранить ответ в кеше (если это дозволено заголовками ответа);
- **`"no-cache"`** -- в случае, если существует кешированный ответ - создать условный запрос, в противном же случае - обычный запрос. Сохранить ответ в  HTTP-кеше;
- **`"force-cache"`** -- использовать ответ из HTTP-кеша, даже если он устаревший. Если же ответ в HTTP-кеше отсутствует, сделать обычный HTTP-запрос, действовать как обычно;
- **`"only-if-cached"`** -- использовать ответ из HTTP-кеша, даже если он устаревший. Если же ответ в HTTP-кеше отсутствует, тогда выдаётся ошибка. Это работает, только когда `mode` установлен в `"same-origin"`.

## Перенаправление

Обычно `fetch` следует таким HTTP-перенаправлениям, как 301, 302 и так далее.

Это можно поменять при помощи опции `redirect`:

- **`"follow"`** -- стоит по умолчанию, следовать HTTP-перенаправлениям,
- **`"error"`** -- ошибка в случае HTTP-перенаправления,
- **`"manual"`** -- не следовать HTTP-перенаправлению, но установить адрес перенаправления в `response.url`, а `response.redirected` будет иметь значение `true`, чтобы мы могли сделать перенаправление на новый адрес вручную.

## integrity

Опция `integrity` позволяет проверить, соответствует ли ответ известной заранее контрольной сумме.

Как описано в [спецификации] (https://w3c.github.io/webappsec-subresource-integrity/), поддерживаемыми хеш-функциями являются SHA-256, SHA-384 и SHA-512. В зависимости от браузера, могут быть и другие.

Например, мы скачиваем файл, и мы точно знаем, что контрольная сумма его SHA-256 равна "abc" (разумеется, настоящая контрольная сумма будет длиннее).

Мы можем добавить это в опцию `integrity` вот так:

```js
fetch('http://site.com/file', {
  integrity: 'sha256-abd'
});
```

Затем `fetch` самостоятельно вычислит SHA-256 и сравнит его с нашей строкой. В случае несоответствия срабатывает ошибка.

## keepalive

Опция `keepalive` указывает на то, что запрос может пережить страницу.

Например, для улучшения опыта взаимодействия мы собираем статистические данные о том, как посетитель ведёт себя на нашей странице (на что он кликает, части страницы, которые он просматривает).

Когда посетитель покидает нашу страницу - мы хотим сохранить это на нашем сервере.

Для этого мы можем использовать `window.onunload`:

```js run
window.onunload = function() {
  fetch('/analytics', {
    method: 'POST',
    body: "statistics",
*!*
    keepalive: true
*/!*
  });
};
```

Обычно, когда документ выгружен, все связанные с ним сетевые запросы прерываются. Но опция `keepalive` указывает браузеру выполнять запрос в фоновом режиме даже после того, как пользователь покидает страницу. Поэтому важно, чтобы наш запрос был успешным.

- Мы не можем посылать мегабайты: лимит тела для запроса с keepalive - 64Кбайт.
    - Если мы собрали достаточно данных, мы можем отправлять их регулярно, и это не будет большой нагрузкой для запроса при "onunload".
    - Этот лимит распространяется на все текущие запросы. Однако, мы можем обойти это правило, послав 100 запросов одновременно - каждый по 64Кбайт.
- Мы не получим ответ от сервера, если запрос сделан при `onunload`: так как в тот момент документ уже выгружен.
    - Обычно сервер посылает пустой ответ на такие запросы, так что это не является проблемой.
