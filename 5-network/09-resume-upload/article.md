# Возобновляемая загрузка файлов

С помощью метода `fetch` можно достаточно просто загрузить файл на сервер.

Но как возобновить загрузку, если соединение прервалось? Для этого не предусмотрено какого-то встроенного способа, но у нас есть все средства, чтобы решить эту задачу самостоятельно.

Возобновляемая загрузка должна сопровождаться индикацией прогресса, так как мы ожидаем, что могут загружаться большие по весу файлы. Поскольку `fetch` не позволяет отслеживать прогресс загрузки, то мы будем использовать [XMLHttpRequest](info:xmlhttprequest).

## Не очень полезное событие progress

Чтобы возобновить загрузку, нам нужно знать, какая часть файла была успешно передана до того, как соединение прервалось.

Можно установить обработчик `xhr.upload.onprogress`, чтобы отслеживать процесс загрузки.

К сожалению, это бесполезно, так как этот обработчик вызывается, только когда данные *отправляются*, но были ли они получены сервером? Браузер этого не знает.

Возможно, отправленные данные оказались в буфере прокси-сервера локальной сети или удалённый сервер просто отключился и не смог принять их, или данные потерялись где-то по пути при разрыве соединения и так и не достигли пункта назначения.

Таким образом, событие `progress` подходит только для того, чтобы показывать красивый индикатор загрузки, не более.

Для возобновления же загрузки нужно точно знать, сколько байт было получено сервером. И только сам сервер может поделиться с нами этой информацией.

## Алгоритм

1. Во-первых, давайте присвоим загружаемому файлу уникальный идентификатор
    ```js
    let fileId = file.name + '-' + file.size + '-' + +file.lastModifiedDate;
    ```
    Это нужно, чтобы при возобновлении загрузки серверу было понятно, какой файл мы продолжаем загружать.

2. Далее, посылаем запрос к серверу с просьбой указать количество уже полученных байтов:
    ```js
    let response = await fetch('status', {
      headers: {
        'X-File-Id': fileId
      }
    });

    // сервер получил столько-то байтов
    let startByte = +await response.text();
    ```

    Предполагается, что сервер учитывает загружаемые файлы с помощью заранее настроенного заголовка `X-File-Id`.

3. Затем мы можем использовать метод `slice` объекта `Blob`, чтобы отправить данные, начиная со `startByte` байта:
    ```js
    xhr.open("POST", "upload", true);

    // отправка идентификатора файла, чтобы сервер знал, загрузку чего мы потом возобновим
    xhr.setRequestHeader('X-File-Id', fileId);
    // отправка номера байта, начиная с которого мы будем отправлять данные. Таким образом, сервер поймёт, что мы возобновляем загрузку
    xhr.setRequestHeader('X-Start-Byte', startByte);

    xhr.upload.onprogress = (e) => {
      console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);
    };

    // файл может быть взят из input.files[0] или другого источника
    xhr.send(file.slice(startByte));
    ```

    Здесь мы посылаем серверу и идентификатор файла в заголовке `X-File-Id`, чтобы он знал, что мы загружаем, и номер стартового байта в заголовке `X-Start-Byte`, чтобы он понял, что мы продолжаем закачку, а не начинаем её с нуля.

    Сервер должен проверить информацию на своей стороне, и если обнаружится, что такой файл уже когда-то загружался, и его текущий размер равен значению из заголовка `X-Start-Byte`, то вновь принимаемые данные добавлять в этот файл.


Ниже представлен демо-код как для сервера (Node.js), так и для клиента.

Пример работает только частично на этом сайте, так как Node.js здесь располагается за другим веб-сервером Nginx, который сохраняет в своём буфере все загружаемые файлы и передаёт их дальше в Node.js только после завершения загрузки.

Но вы можете скачать код и запустить его локально, чтобы увидеть полный пример в действии:

[codetabs src="upload-resume" height=200]

Как вы видите, современные методы работы с сетью очень близки по своим возможностям к файловым менеджерам -- контроль заголовков, индикация прогресса загрузки, отправка данных по частям и так далее.
